# -*- coding: utf-8 -*-
"""nbeatsx_full_features.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P9BXq6jl8dx5HiXTbwYAm3fudkt5KkFI
"""

import os
from google.colab import drive
drive.mount('/content/drive')
sample_data_path = '/content/drive/MyDrive/Colab Notebooks'
files=os.listdir(sample_data_path)
print(files)
ff='/content/drive/MyDrive/Colab Notebooks/featured_shihara.xlsx'
import pandas as pd
df=pd.read_excel(ff,engine='openpyxl')
print(df.head())
print(df.dtypes)
df["Date"]=pd.to_datetime(df["Date"])
nf_df=df

# Required libraries
!pip install neuralforecast
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from neuralforecast import NeuralForecast
from neuralforecast.models import NBEATSx
from neuralforecast.utils import AirPassengersDF
from sklearn.metrics import mean_absolute_error, mean_squared_error

print(nf_df.head())

# Time-based features
nf_df['day_of_month'] = nf_df['Date'].dt.day
nf_df['month'] = nf_df['Date'].dt.month
nf_df['year'] = nf_df['Date'].dt.year
nf_df['quarter'] = nf_df['Date'].dt.quarter
nf_df['is_weekend'] = nf_df['Date'].dt.dayofweek >= 5
nf_df['is_month_start'] = nf_df['Date'].dt.is_month_start.astype(int)
nf_df['is_month_end'] = nf_df['Date'].dt.is_month_end.astype(int)

# Advanced rolling features with min_periods to handle NaN values
for window in [7, 14, 30]:
    nf_df[f'rolling_mean_{window}d'] = nf_df['Normalized_Balance'].rolling(window=window, min_periods=1).mean()
    nf_df[f'rolling_std_{window}d'] = nf_df['Normalized_Balance'].rolling(window=window, min_periods=1).std()
    nf_df[f'rolling_min_{window}d'] = nf_df['Normalized_Balance'].rolling(window=window, min_periods=1).min()
    nf_df[f'rolling_max_{window}d'] = nf_df['Normalized_Balance'].rolling(window=window, min_periods=1).max()
    nf_df[f'rolling_skew_{window}d'] = nf_df['Normalized_Balance'].rolling(window=window, min_periods=1).skew()
    nf_df[f'rolling_kurt_{window}d'] = nf_df['Normalized_Balance'].rolling(window=window, min_periods=1).kurt()

# Momentum and rate of change features
nf_df['balance_diff_1d'] = nf_df['Normalized_Balance'].diff(1)
nf_df['balance_diff_7d'] = nf_df['Normalized_Balance'].diff(7)
nf_df['balance_pct_change_1d'] = nf_df['Normalized_Balance'].pct_change(1).fillna(0).clip(-1, 1)  # Clip to [-1, 1]
nf_df['balance_pct_change_7d'] = nf_df['Normalized_Balance'].pct_change(7).fillna(0).clip(-1, 1)  # Clip to [-1, 1]

# Exponential weighted features
nf_df['ewm_7d'] = nf_df['Normalized_Balance'].ewm(span=7, min_periods=1).mean()
nf_df['ewm_14d'] = nf_df['Normalized_Balance'].ewm(span=14, min_periods=1).mean()
nf_df['ewm_30d'] = nf_df['Normalized_Balance'].ewm(span=30, min_periods=1).mean()

# Fill NaN values
nf_df = nf_df.fillna(method='bfill').fillna(method='ffill')

print(nf_df.head())

# Data preparation: Split into train (90%) and test (10%)
train_size = int(len(nf_df) * 0.9)
train_df = nf_df.iloc[:train_size].copy()
test_df = nf_df.iloc[train_size:].copy()

print(f"Training set size: {len(train_df)}")
print(f"Testing set size: {len(test_df)}")

# Handle missing values in both datasets
train_df = train_df.fillna(method='bfill').fillna(method='ffill')
test_df = test_df.fillna(method='bfill').fillna(method='ffill')

# Set up the data in NeuralForecast format
train_data = train_df.copy()
train_data['unique_id'] = 'balance'  # Add required ID column
train_data = train_data.rename(columns={'Date': 'ds', 'Normalized_Balance': 'y'})

test_data = test_df.copy()
test_data['unique_id'] = 'balance'
test_data = test_data.rename(columns={'Date': 'ds', 'Normalized_Balance': 'y'})

# Define exogenous variables (all features except date, target and ID)
exogenous_vars = [col for col in train_data.columns
                  if col not in ['ds', 'y', 'unique_id']]

print(f"Using {len(exogenous_vars)} exogenous variables: {exogenous_vars}")

# Define forecast horizon
horizon = 30

model = NBEATSx(
    h=horizon,                   # Forecast horizon
    input_size=160,        # Input window length
    futr_exog_list=exogenous_vars,  # Use future exogenous variables if available
    hist_exog_list=exogenous_vars,  # Use historical exogenous variables
    random_seed=42,              # For reproducibility
    scaler_type='standard'       # Standardize the data
)

# Create the forecaster
forecaster = NeuralForecast(
    models=[model],
    freq='D'  # Daily frequency
)

# Fit the model (train)
forecaster.fit(df=train_data)

# Generate forecasts
forecast_df = forecaster.predict(
    futr_df=test_data.iloc[:horizon]  # First 30 days of test data for comparison
)

# Extract actual values and forecasts
actual = test_data['y'].iloc[:horizon].values
forecast = forecast_df.loc[forecast_df['unique_id'] == 'balance', 'NBEATSx'].values

# Plot results
plt.figure(figsize=(12, 6))
plt.plot(range(horizon), actual, label='Actual', marker='o', alpha=0.7)
plt.plot(range(horizon), forecast, label='NBEATSx Forecast', marker='x', alpha=0.7)
plt.title('30-Day Balance Forecast vs Actual')
plt.xlabel('Days')
plt.ylabel('Normalized Balance')
plt.legend()
plt.grid(True)
plt.tight_layout()

# Calculate error metrics
mae = mean_absolute_error(actual, forecast)
rmse = np.sqrt(mean_squared_error(actual, forecast))
# Add small epsilon to avoid division by zero in MAPE calculation
mape = np.mean(np.abs((actual - forecast) / (actual + 1e-8))) * 100

print(f"Mean Absolute Error (MAE): {mae:.4f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.4f}")
print(f"Mean Absolute Percentage Error (MAPE): {mape:.2f}%")

plt.show()

